整理一下适用场景，便于遇到合适场景时通过使用设计模式更好地去掌握设计模式

设计模式分创建型、行为型、结构型

创建型

策略模式：某一个功能有多种方案可以选择的情景 
单例模式：创建独一无二的，只能有一个实例的对象；一个无状态的类，使用该模式节省资源 
工厂模式：创建新对象，且该对象需要被被封装 
抽象工厂模式：用于创建一组产品（各产品不一定相同） 
建造模式：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。 
原型模式：用new创建一个对象需要非常繁琐的数据准备或者权限

行为型

模板模式：架构师用于搭建项目的框架，架构师定好了骨架，程序员继承了骨架的结构之后，负责往里面填空 
命令模式：向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道请求的操作是什么；让程序运行的任何时刻去调用这个方法； 
将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化 
迭代器模式：需要顺序访问一个组合内的多个对象的时候使用。 
观察者模式：异步编程；主题是具有状态的对象，并且可以控制这些状态，观察者使用这些状态，虽然这些状态不属于它们 
状态模式：一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为；个操作中含有庞大的多分支结构，并且这些分支决定于对象的状态 
职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 
中介者模式：用一个中介对象封装一些列的对象交互 
访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作 
备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态

结构型

装饰者模式：增加行为到包装对象上，在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责 
代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问 
外观模式：子系统中的一组接口提供一致的界面 
适配器模式：将一类的接口转换成客户希望的另外一个接口；使得原本由于接口不兼容而不能一起工作那些类可以一起工作 
桥梁模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化 
组合模式：将对象组合成树形结构以表示部分整体的关系；使得用户对单个对象和组合对象的使用具有一致性 
享元模式： 
享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。

---------------------

本文来自 寂灭万乘 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/qq_34244317/article/details/77808913?utm_source=copy 